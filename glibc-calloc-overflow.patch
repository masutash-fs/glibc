===================================================================
RCS file: /cvs/glibc/libc/malloc/malloc.c,v
retrieving revision 1.87
retrieving revision 1.87.2.3
diff -u -r1.87 -r1.87.2.3
--- libc/malloc/malloc.c	2001/09/19 03:23:27	1.87
+++ libc/malloc/malloc.c	2002/08/09 18:28:55	1.87.2.3
@@ -1,5 +1,5 @@
 /* Malloc implementation for multiple threads without lock contention.
-   Copyright (C) 1996,1997,1998,1999,2000,2001 Free Software Foundation, Inc.
+   Copyright (C) 1996-2001, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Wolfram Gloger <wmglo@dent.med.uni-muenchen.de>
    and Doug Lea <dl@cs.oswego.edu>, 1996.
@@ -19,7 +19,7 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
-/* $Id$
+/* $Id$
 
   This work is mainly derived from malloc-2.6.4 by Doug Lea
   <dl@cs.oswego.edu>, which is available from:
@@ -3795,14 +3795,26 @@
 {
   arena *ar_ptr;
   mchunkptr p, oldtop;
-  INTERNAL_SIZE_T sz, csz, oldtopsize;
+  INTERNAL_SIZE_T bytes, sz, csz, oldtopsize;
   Void_t* mem;
 
 #if defined _LIBC || defined MALLOC_HOOKS
   __malloc_ptr_t (*hook) __MALLOC_PMT ((size_t, __const __malloc_ptr_t)) =
     __malloc_hook;
+
+  /* size_t is unsigned so the behavior on overflow is defined.  */
+    bytes = n * elem_size;
+#define HALF_INTERNAL_SIZE_T \
+  (((INTERNAL_SIZE_T) 1) << (8 * sizeof (INTERNAL_SIZE_T) / 2))
+  if (__builtin_expect ((n | elem_size) >= HALF_INTERNAL_SIZE_T, 0)) {
+    if (elem_size != 0 && bytes / elem_size != n) {
+      __set_errno (ENOMEM);
+      return 0;
+    }
+  }
+
   if (hook != NULL) {
-    sz = n * elem_size;
+    sz = bytes;
 #if defined __GNUC__ && __GNUC__ >= 2
     mem = (*hook)(sz, RETURN_ADDRESS (0));
 #else
@@ -3819,7 +3831,7 @@
   }
 #endif
 
-  if(request2size(n * elem_size, sz))
+  if(request2size(bytes, sz))
     return 0;
   arena_get(ar_ptr, sz);
   if(!ar_ptr)
@@ -3862,7 +3874,7 @@
     }
     if (p == 0) return 0;
   }
-  mem = BOUNDED_N(chunk2mem(p), n * elem_size);
+  mem = BOUNDED_N(chunk2mem(p), bytes);
 
   /* Two optional cases in which clearing not necessary */
 
@@ -4899,9 +4911,9 @@
 {
   void *mem;
 
-  /* Test whether the SIZE argument is valid.  It must be a power of
-     two multiple of sizeof (void *).  */
-  if (size % sizeof (void *) != 0 || (size & (size - 1)) != 0)
+  /* Test whether the ALIGNMENT argument is valid.  It must be a power
+     of two multiple of sizeof (void *).  */
+  if (alignment % sizeof (void *) != 0 || (alignment & (alignment - 1)) != 0)
     return EINVAL;
 
   mem = __libc_memalign (alignment, size);
