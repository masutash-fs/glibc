Avoid integer overflow when using TZ in form stdNdst without explicit dst rules,
when:
 * using 32-bit time_t
 * first system timezone transition rule begins before 1901 (i.e. ~INT32_MAX)
 * TZ is on west of system timezone
--- glibc-2.27/time/tzfile.c.orig	2018-02-10 11:10:05.455102136 +0100
+++ glibc-2.27/time/tzfile.c	2018-07-14 21:25:23.090397420 +0200
@@ -543,6 +543,25 @@
    We will use the names and offsets from the user, and the rules
    from the TZDEFRULES file.  */
 
+static void time_adjust_limited(time_t *value, long diff)
+{
+  static time_t time_min = (sizeof(time_t) == 4) ? INT32_MIN : INT64_MIN;
+  static time_t time_max = (sizeof(time_t) == 4) ? INT32_MAX : INT64_MAX;
+  if (diff < 0)
+  {
+    if (*value >= time_min - diff)
+      *value += diff;
+    else
+      *value = time_min;
+  } else if (diff > 0)
+  {
+    if (*value <= time_max - diff)
+      *value += diff;
+    else
+      *value = time_max;
+  }
+}
+
 void
 __tzfile_default (const char *std, const char *dst,
 		  long int stdoff, long int dstoff)
@@ -590,13 +609,13 @@
 	   wall clock time as of the previous transition was DST.  Correct
 	   for the difference between the rule's DST offset and the user's
 	   DST offset.  */
-	transitions[i] += dstoff - rule_dstoff;
+	time_adjust_limited(&transitions[i], dstoff - rule_dstoff);
       else
 	/* This transition is in "local wall clock time", and wall clock
 	   time as of this iteration is non-DST.  Correct for the
 	   difference between the rule's standard offset and the user's
 	   standard offset.  */
-	transitions[i] += stdoff - rule_stdoff;
+	time_adjust_limited(&transitions[i], stdoff - rule_stdoff);
 
       /* The DST state of "local wall clock time" for the next iteration is
 	 as specified by this transition.  */
