--- libc/elf/dl-close.c	2003/03/16 01:03:52	1.95
+++ libc/elf/dl-close.c	2003/04/27 06:19:09	1.98
@@ -80,7 +80,7 @@
 	return true;
     }
 
-  while (idx - disp > disp == 0 ? 1 + GL(dl_tls_static_nelem) : 0)
+  while (idx - disp > (disp == 0 ? 1 + GL(dl_tls_static_nelem) : 0))
     {
       --idx;
 
@@ -321,8 +321,9 @@
   _dl_debug_state ();
 
 #ifdef USE_TLS
-  size_t tls_free_start, tls_free_end;
-  tls_free_start = tls_free_end = GL(dl_tls_static_used);
+  size_t tls_free_start;
+  size_t tls_free_end;
+  tls_free_start = tls_free_end = NO_TLS_OFFSET;
 #endif
 
   /* Check each element of the search list to see if all references to
@@ -365,15 +366,56 @@
 		/* All dynamically loaded modules with TLS are unloaded.  */
 		GL(dl_tls_max_dtv_idx) = GL(dl_tls_static_nelem);
 
-	      if (imap->l_tls_offset != 0)
+	      if (imap->l_tls_offset != NO_TLS_OFFSET)
 		{
 		  /* Collect a contiguous chunk built from the objects in
 		     this search list, going in either direction.  When the
 		     whole chunk is at the end of the used area then we can
 		     reclaim it.  */
+# if TLS_TCB_AT_TP
+		  if (tls_free_start == NO_TLS_OFFSET
+		      || (size_t) imap->l_tls_offset == tls_free_start)
+		    {
+		      /* Extend the contiguous chunk being reclaimed.  */
+		      tls_free_start
+			= imap->l_tls_offset - imap->l_tls_blocksize;
+
+		      if (tls_free_end == NO_TLS_OFFSET)
+			tls_free_end = imap->l_tls_offset;
+		    }
+		  else if (imap->l_tls_offset - imap->l_tls_blocksize
+			   == tls_free_end)
+		    /* Extend the chunk backwards.  */
+		    tls_free_end = imap->l_tls_offset;
+		  else
+		    {
+		      /* This isn't contiguous with the last chunk freed.
+			 One of them will be leaked unless we can free
+			 one block right away.  */
+		      if (tls_free_end == GL(dl_tls_static_used))
+			{
+			  GL(dl_tls_static_used) = tls_free_start;
+			  tls_free_end = imap->l_tls_offset;
+			  tls_free_start
+			    = tls_free_end - imap->l_tls_blocksize;
+			}
+		      else if ((size_t) imap->l_tls_offset
+			       == GL(dl_tls_static_used))
+			GL(dl_tls_static_used)
+			  = imap->l_tls_offset - imap->l_tls_blocksize;
+		      else if (tls_free_end < (size_t) imap->l_tls_offset)
+			{
+			  /* We pick the later block.  It has a chance to
+			     be freed.  */
+			  tls_free_end = imap->l_tls_offset;
+			  tls_free_start
+			    = tls_free_end - imap->l_tls_blocksize;
+			}
+		    }
+# elif TLS_DTV_AT_TP
 		  if ((size_t) imap->l_tls_offset == tls_free_end)
 		    /* Extend the contiguous chunk being reclaimed.  */
-		    tls_free_end += imap->l_tls_blocksize;
+		    tls_free_end -= imap->l_tls_blocksize;
 		  else if (imap->l_tls_offset + imap->l_tls_blocksize
 			   == tls_free_start)
 		    /* Extend the chunk backwards.  */
@@ -387,6 +429,9 @@
 		      tls_free_start = imap->l_tls_offset;
 		      tls_free_end = tls_free_start + imap->l_tls_blocksize;
 		    }
+# else
+#  error "Either TLS_TCB_AT_TP or TLS_DTV_AT_TP must be defined"
+# endif
 		}
 	    }
 #endif

